# -*- coding: utf-8 -*-
"""Untitled95.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PHIi64RLW8qTnigPa8Q1XyGxxJ2hE4iN
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import cv2, math, numpy as np, pandas as pd, tempfile, os
# from ultralytics import YOLO
# from deep_sort_realtime.deepsort_tracker import DeepSort
# from tqdm import tqdm
# 
# # ----------------- SETTINGS -----------------
# PIXEL_SPEED_STOP = 1.0
# SUDDEN_DECEL = 0.6
# IOU_THRESHOLD = 0.15
# IMMOBILITY_FRAMES = 40
# 
# model = YOLO("yolo11n.pt")  # change to your custom YOLOv11 weights if you have
# tracker = DeepSort(max_age=30)
# 
# vehicle_classes = {2:"Car", 3:"Motorcycle", 5:"Bus", 7:"Truck"}  # COCO IDs
# 
# def iou(b1,b2):
#     x1,y1,x2,y2=b1; X1,Y1,X2,Y2=b2
#     inter = max(0,min(x2,X2)-max(x1,X1)) * max(0,min(y2,Y2)-max(y1,Y1))
#     return inter / ((x2-x1)*(y2-y1)+(X2-X1)*(Y2-Y1)-inter+1e-6)
# 
# # ----------------- STREAMLIT UI -----------------
# st.title("ðŸš— CCTV Accident Detection - YOLOv11 + Tracker")
# uploaded = st.file_uploader("Upload CCTV Video", type=["mp4","avi","mov","mkv"])
# 
# if uploaded:
#     st.video(uploaded)
# 
#     if st.button("Run Accident Detection"):
#         # Save file temporarily
#         tfile = tempfile.NamedTemporaryFile(delete=False)
#         tfile.write(uploaded.read())
#         video_path = tfile.name
# 
#         cap = cv2.VideoCapture(video_path)
#         fps = cap.get(cv2.CAP_PROP_FPS)
#         W,H = int(cap.get(3)),int(cap.get(4))
#         frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
# 
#         out = cv2.VideoWriter("result.mp4", cv2.VideoWriter_fourcc(*'mp4v'), fps, (W,H))
# 
#         track_hist={}; events=[]
#         progress = st.progress(0)
#         f=0
# 
#         while True:
#             ret, frame = cap.read()
#             if not ret: break
#             f+=1
# 
#             results = model(frame, conf=0.4)[0]
#             det=[]
#             for b in results.boxes:
#                 x1,y1,x2,y2 = map(int,b.xyxy[0])
#                 cls = int(b.cls)
#                 det.append(([x1,y1,x2,y2], float(b.conf), cls))
# 
#             tracks = tracker.update_tracks([(d[0],d[1],d[2]) for d in det], frame=frame)
#             curr={}
# 
#             for t in tracks:
#                 if not t.is_confirmed(): continue
#                 tid = int(t.track_id)
#                 x1,y1,x2,y2 = map(int, t.to_ltrb())
#                 cls_name = vehicle_classes.get(int(t.get_det_class()), "Vehicle")
# 
#                 cx,cy = (x1+x2)/2,(y1+y2)/2
# 
#                 prev = track_hist[tid][-1] if tid in track_hist else None
#                 dist = math.hypot(cx-(prev["cx"] if prev else cx), cy-(prev["cy"] if prev else cy))
# 
#                 track_hist.setdefault(tid, []).append({"frame":f,"bbox":(x1,y1,x2,y2),"cx":cx,"cy":cy,"dist":dist,"type":cls_name})
#                 curr[tid]=track_hist[tid][-1]
# 
#                 # Draw box + speed
#                 speed = np.mean([x["dist"] for x in track_hist[tid][-5:]]) * fps / 10  # px â†’ approx speed
#                 cv2.rectangle(frame,(x1,y1),(x2,y2),(255,255,0),2)
#                 cv2.putText(frame,f"{cls_name} ID:{tid} {speed:.1f}px/s",
#                             (x1,y1-5),cv2.FONT_HERSHEY_SIMPLEX,0.5,(255,255,255),2)
# 
#             # Collision detection
#             for a,b in [(a,b) for a in curr for b in curr if a<b]:
#                 if iou(curr[a]["bbox"],curr[b]["bbox"]) > IOU_THRESHOLD:
#                     pa,pb = track_hist[a],track_hist[b]
#                     if len(pa)>5 and len(pb)>5:
#                         sA=np.mean([x["dist"] for x in pa[-5:]])
#                         sB=np.mean([x["dist"] for x in pb[-5:]])
#                         pA=np.mean([x["dist"] for x in pa[-10:-5]])+1e-6
#                         pB=np.mean([x["dist"] for x in pb[-10:-5]])+1e-6
#                         if sA/pA<SUDDEN_DECEL or sB/pB<SUDDEN_DECEL:
#                             events.append(["collision",f,a,b])
#                             cv2.putText(frame,"ACCIDENT!",(50,50),
#                                         cv2.FONT_HERSHEY_SIMPLEX,1,(0,0,255),3)
# 
#             # Immobility
#             for tid,h in track_hist.items():
#                 if len(h)>IMMOBILITY_FRAMES:
#                     if np.mean([x["dist"] for x in h[-IMMOBILITY_FRAMES:]]) < PIXEL_SPEED_STOP:
#                         events.append(["immobile",f,tid])
#                         cv2.putText(frame,"VEHICLE STOPPED",(60,70),
#                                     cv2.FONT_HERSHEY_SIMPLEX,1,(0,165,255),3)
# 
#             out.write(frame)
#             progress.progress(f/frames)
# 
#         cap.release(); out.release()
# 
#         st.success("âœ… Detection Complete!")
#         st.video("result.mp4")
# 
#         # Format accident descriptions
#         if events:
#             st.error("âš  Accident Detected!")
#             df = pd.DataFrame(events, columns=["Type","Frame","VehA","VehB"])
#             st.dataframe(df)
# 
#             for e in events:
#                 if e[0]=="collision":
#                     st.write(f"ðŸš¨ **Collision at frame {e[1]}** between Vehicle {e[2]} and Vehicle {e[3]}")
#                 else:
#                     st.write(f"ðŸš— Vehicle **{e[2]} stopped abnormally** at frame {e[1]}")
#         else:
#             st.success("âœ… No accident found.")
#

